% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/itertracer.R
\name{itertracer}
\alias{itertracer}
\title{Trace Iterations}
\usage{
itertracer(
  param_init,
  step_funs,
  fixed = list(),
  shared = new.env(parent = emptyenv()),
  callbacks = list(),
  n_iter = 200L,
  n_chains = 1L,
  n_parallel = 1L,
  n_burn = 0L,
  n_skip = 0L,
  seeds = NULL,
  read_cache = TRUE,
  clean_cache = FALSE
)
}
\arguments{
\item{param_init}{\verb{[list]}
\itemize{
\item a named list of arrays for where to start sampling for each parameter
\item there must be an element in \code{step_funs} for each element here
(matching by names)
\item all elements must be one of
\itemize{
\item numeric array
\item list of arrays, with one array for each chain --- hence the length
must be equal to \code{n_chains}
}
}}

\item{step_funs}{\link{list}``
\itemize{
\item a list of functions for sampling each random variables' step (oneitertracer
iteration = one step for each variable)
\item matched with \code{param_init} based on names
\item the order of calling each step fun is determined by callback \code{param_order}
}}

\item{fixed}{\verb{[list]}
\itemize{
\item passed to \code{step_funs} and \code{callbacks} in \code{arg_list[["fixed"]]}
\item \code{fixed} is a list, so if you modify any of it's elements in
\code{step_funs} or \code{callbacks}, you actually create a new list and
you cannot pass changes in \code{fixed} to other functions
}}

\item{shared}{\verb{[environment, list]}
\itemize{
\item \code{list}: a list of \code{environment} objects, one for each chain
\item \code{environment}:
\itemize{
\item \code{shared} is passed to all \code{step_funs} and \code{callbacks}
in \code{arg_list[["shared"]]}
\item since it's an environment, you can save any results computed in one
function to be used by others (\strong{NOTE}: in parallel computation you of
course cannot share results between different threads)
}
}}

\item{callbacks}{\verb{[list]}
\itemize{
\item named list of functions called at various points of the process (pre-iter,
post-iter, etc.)
\item supplied to \link{itertracer_callbacks}
}}

\item{n_iter}{number of iterations}

\item{n_chains}{number of separate chains to sample}

\item{n_parallel}{number of parallel processes to run}

\item{n_burn}{number of iterations out of \code{n_iter} to run before
samples will be saved and included in output}

\item{n_skip}{keep every \code{(n_skip + 1)}'th sample}

\item{seeds}{vector of numbers or NULL; if not NULL, each of these is
passed to each separate chain; if NULL these are picked automatically
(and each chain has a different seed)}

\item{read_cache}{if TRUE, will read the trace at the end of iterating
into R; else the samples will be left in the trace folder only --- but
see \code{clean_cache}}

\item{clean_cache}{if TRUE, will delete any folder created to store samples}
}
\description{
Run an iterative process and collect a trace of the iterations.
}
\examples{
## beta-binomial Gibbs sampling, multi-core

g <- itertracer(
  fixed = list(n = 20L),
  param_init = lapply(list(x = 10, theta = 0.5), as.array),
  step_funs = list(
    x = function(arg_list) {
      rbinom(
        n = 1,
        size = arg_list[["fixed"]][["n"]],
        prob = arg_list[["param_list"]][["theta"]]
      )
    },
    theta = function(arg_list) {
      rbeta(
        n = 1,
        shape1 = 2 + arg_list[["param_list"]][["x"]],
        shape2 = 4 + arg_list[["fixed"]][["n"]] - arg_list[["param_list"]][["x"]]
      )
    }
  ),
  n_chains = 1L,
  n_iter = 300,
  n_burn = 50L,
  n_skip = 4L,
  n_parallel = 1L
)

}
